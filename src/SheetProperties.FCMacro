"""
|-------------------------------------------------------------------------------|
|                  Spreadsheet Cells Properties Actions                         |
|-------------------------------------------------------------------------------|
| About:                                                                        |
|                                                                               |
| This Macro helps performing actions (e.g., set, clear) on cells properties    |
| of FreeCAD spreadsheet.                                                       |
|                                                                               |
| Setting cell properties is based on visible data in respective columns of the |
| same spreadsheet.                                                             |
|                                                                               |
| The data source columns for the cells properties (i.e., Alias, Units), as     |
| well as the target column (i.e., Value), need to have appropriate headers.    |
|                                                                               |
| These columns with their headers (i.e., Alias, Units, Value) can be included  |
| in the spreadsheet in any order and in any column position, as long as each   |
| header with its respective data are given in the same column.                 |
|                                                                               |
| The headers can be placed at any row, as long as all the headers are on the   |
| same row. The target column header (i.e., Value) is mandatory, the headers    |
| for the data source columns for the cells properties (i.e., Alias, Units) can |
| be configured each as mandatory or optional.                                  |
|                                                                               |
| Empty rows can be placed anywhere, including inside the range occupied by     |
| the cells of these columns with their headers (i.e., Alias, Units, Value).    |
|                                                                               |
| Missing or invalid source data for the cells properties are ignored.          |
|                                                                               |
| Additional data (e.g., comments, description, tabular data) can be placed     |
| above or below the range occupied by the cells of these columns with their    |
| headers (i.e., Alias, Units, Value).                                          |
|                                                                               |
| Additional columns can be placed to the left, right, or between these columns |        
| with their headers. This additional data may freely include any name of the   |
| headers, as long as it is part of a longer text.                              |
|                                                                               |
| The location of the headers, and the starting and ending rows of the range of |
| these columns are discovered automatically after the target spreadsheet is    |
| selected. The user may however, limit this range if it is desired so.         |
|                                                                               | 
| The Macro supports multiple spreadsheets included in a single document. It    |
| allows selecting the target spreadsheet using a ComboBox (aka, pop-up menu),  |
| or from the tree view. Both methods of selecting a target spreadsheet can be  |
| used interchangeably. The Macro syncs between the tree view selection and     |
| the ComboBox, bi-directionally.                                               |
| ------------------------------------------------------------------------------|
| Disclaimer of warranties and limitation of liability:                         |
|                                                                               |
| Use at your own risk. The author assumes no liability for data loss.          |
| It is advised to backup your data frequently.                                 |
|                                                                               |
| Copyright (c) 2017 - 2018, Uri Benchetrit, <uribench@gmail.com>.              |
| All rights reserved.                                                          |
| ------------------------------------------------------------------------------|
| License:                                                                      |
|                                                                               |
| This work is licensed under GNU Lesser General Public License (LGPL).         |
| License details:  https://www.gnu.org/licenses/lgpl-3.0.html.                 |
| ------------------------------------------------------------------------------|
"""

__title__   = "SheetPropertiesActions"
__author__  = "Uri Benchetrit, <uribench@gmail.com>"
__version__ = "1.0.0"
__date__    = "2018-02-01"

__Comment__ = "Actions (e.g., set or clear) on Spreadsheet Cells Properties"

__Wiki__    = "TBD"
__Help__    = "See the About text box given above"
__Status__  = "stable"
__Requires__ = "FreeCAD 0.17dev"

from PySide import QtGui, QtCore
import Spreadsheet
import string
from itertools import product
import re
import sys
import json

def main():
    """
    Gist of this Macro:
    ------------------

    The ActiveDocumentSheets class holds the context of this Macro. It maintains 
    information about the active document, such as a list of all the available 
    spreadsheets, useful document level constants (e.g., header names for common 
    columns), and useful maps (e.g., from spreadsheet label to spreadsheet object 
    reference). One instance of ActiveDocumentSheets is needed for this Macro and 
    it should not have any spreadsheet specific information.

    The RequestParameters class holds spreadsheet specific information. This 
    includes for instance, the location of the common columns, the ranges of usable 
    data source rows. One instance is created for every spreadsheet found in the 
    active document. The RequestParameters has to be ready with all of its 
    information prior to performing any action on the associated spreadsheet.

    The SheetPropertiesActions class provides the possible actions on a spreadsheet 
    (e.g., setting and clearing cell properties). It requires a concrete 
    RequestParameters instance prior to performing any of its actions.

    The SheetPropertiesActionsForm is one way of consuming the above. When the 
    SheetPropertiesActionsForm is instantiated, all the RequestParameters instances 
    of all the sheets found for the active document, have been set to reflect the 
    current state of the sheets. The SheetPropertiesActionsForm allows selecting 
    interactively one spreadsheet from the list of known spreadsheets of the active 
    document, identify the appropriate RequestParameters and pass it to the respective 
    SheetPropertiesActions. However, RequestParameters and SheetPropertiesActions can 
    be set and consumed without using a GUI.
    """

    try:
        context = ActiveDocumentSheets()
    except PreconditionError as e:
        print 'Preconditions check failed (Reason: {0})'.format(e.reason)
        return None

    # Note: the SheetPropertiesActionsForm, may be destroyed by the Python 
    # interpreter's garbage collector if a reference to it is not maintained.
    return SheetPropertiesActionsForm(context)

class ActiveDocumentSheets:
    """
    Context of this script. Common to all sheets.

    Attributes:
        HEADER_UNITS                -- constant string defining the expected string for this header
        HEADER_ALIAS                -- constant string defining the expected string for this header
        HEADER_VALUE                -- constant string defining the expected string for this header
        sheetToRequestParamsMap     -- dictionary mapping between spreadsheet reference to request params reference
        sheetLabelToSheetMap        -- dictionary mapping between spreadsheet label to spreadsheet reference
        headerToFunctionsMap        -- dictionary mapping between headers to their respective setting and validation functions
        getSheets()                 -- returns all the spreadsheet included in the active document
        getSelectedSheet()          -- returns the spreadsheet found in the active document
    """

    # Constants
    HEADER_UNITS = 'Units'
    HEADER_ALIAS = 'Alias'
    HEADER_VALUE = 'Value'

    # Useful maps
    sheetToRequestParamsMap = {}
    sheetLabelToSheetMap = {}
    # for each cell property data header associate a tuple in the format of:
    #   Header name: (setting method name, validation function name)
    # it is assumed that the setting methods belong to a 'Spreadsheet::Sheet' object, 
    # and the validation method belong to a 'RequestParameters' object.
    headerToFunctionsMap = {HEADER_UNITS: ('setDisplayUnit', 'validateUnits'), 
                            HEADER_ALIAS: ('setAlias', 'validateAlias')} 

    def __init__(self):
        # Check preconditions
        if App.ActiveDocument is None:
            raise PreconditionError('There is no active document')

        self.activeDocument = App.ActiveDocument

        sheets = self.getSheets()
        if (isEmpty(sheets)):
            raise PreconditionError('No spreadsheets were found in the active document')

        # Initialize useful maps
        for sheet in sheets:
            # Associate an instance of RequestParameters to each known sheet.
            # This way, the request parameters can be cached for each sheet.
            self.sheetToRequestParamsMap.update({sheet: RequestParameters(sheet, self)})
            self.sheetLabelToSheetMap.update({sheet.Label: sheet})

    def getSheets(self):
        """Returns the spreadsheet found in the active document"""

        return App.ActiveDocument.findObjects("Spreadsheet::Sheet")

    def getSelectedSheet(self):
        """Returns the first selected spreadsheet in the active document tree view"""

        result = None

        sel = FreeCADGui.Selection.getSelection()
        # Note: getSelection() returns an empty list if the selected object does not belong to the active document
        if (not isEmpty(sel)) and sel[0].isDerivedFrom('Spreadsheet::Sheet'):
            result = sel[0]

        return result

class RequestParameters:
    """
    Holds the parameters for a request of an action request on the properties 
    of selected cells in the associated spreadsheet.

    Each spreadsheet in the document is associated with an instance of RequestParameters.

    Actual request parameters can be set by using a UI Form (like in this Macro with 
    SheetPropertiesActionsForm), or by using other means.

    Attributes:
        targetSpreadsheet           -- target spreadsheet for actions (e.g., set, clear) on cells properties
        context                     -- context of this script
        initData()                  -- data initializing method for this instance
        hasValidHeaders             -- True if the headers of the target spreadsheet are valid, False otherwise
        invalidHeadersReason        -- reason for invalid headers
        hasValidPropertiesData      -- True if the properties data of the target spreadsheet are valid, False otherwise
        invalidPropertiesDataReason -- reason for invalid properties data
        headersRowNumber            -- row number of the headers
        mandatoryHeaders            -- list of mandatory headers
        headersToLocMap             -- dictionary of {header name : header location} pairs
        headersToColumnMap          -- dictionary of {header name : header column} pairs containing only headers that were found
        dataRowsRanges              -- list of continuous continuous ranges of rows having source data
    """

    MAX_SEARCH_COL = 100    # Max value = 27*26=702='ZZ'
    MAX_SEARCH_ROW = 100    # Max value = 128^2=16,384
    END_DATA_HINT = 5       # Min number of consecutive empty lines 
                            # indicating end row of properties source data

    def __init__(self, sheet, context):
        self.targetSpreadsheet = sheet
        self.context = context
        self.initData()

    def initData(self):
        self.hasValidHeaders = False
        self.invalidHeadersReason = ''
        self.hasValidPropertiesData = False
        self.invalidPropertiesDataReason = ''

        self.headersRowNumber = None
        self.mandatoryHeaders = [self.context.HEADER_ALIAS, self.context.HEADER_VALUE]
        self.headersToLocMap = {self.context.HEADER_UNITS:'', self.context.HEADER_ALIAS:'', self.context.HEADER_VALUE:''}
        self.headersToColumnMap = {}
        self.dataRowsRanges = []    # list of continuous continuous ranges of rows having source data

        # search for the headers in the associated sheet
        self.findSheetHeaders()

        if self.hasValidHeaders:
            self.initHeadersToColumnMap()
            self.dataRowsRanges = self.findDataRowsRanges()

            if isEmpty(self.dataRowsRanges):
                self.hasValidPropertiesData = False
                self.invalidPropertiesDataReason = 'No usable data rows for property setting were provided in \'{0}\' sheet\n'.  \
                                                    format(self.targetSpreadsheet.Label)
            else:
                self.hasValidPropertiesData = True

    def findSheetHeaders(self):
        """"""
        result = False

        searchedHeadersCount = len(self.headersToLocMap)
        uniqueHeadersFound = 0

        for row, col in product(range(1, self.MAX_SEARCH_ROW), range(1, self.MAX_SEARCH_COL)):
                cellLoc = colNumberToColName(col) + str(row)
                cellContent = self.targetSpreadsheet.getContents(cellLoc)
                # check if the current cell content matches any of the possible headers
                for header in self.headersToLocMap.keys():
                    if cellContent.lower() == header.lower():
                        # make sure the header that was found is not a duplicate
                        if self.headersToLocMap[header] == '':
                            self.headersToLocMap[header] = cellLoc                          
                            # set headers row number only when the first header is found
                            if uniqueHeadersFound == 0:
                                self.headersRowNumber = row
                            uniqueHeadersFound += 1
                            result = True
                        else:
                            self.hasValidHeaders = False
                            self.invalidHeadersReason = 'Found a duplicated header: ' + header
                            return False

                # stop searching if all the possible headers were found
                if uniqueHeadersFound == searchedHeadersCount:
                    break

        # validate search results with rules additional to those applied during the search for the headers in the spreadsheet 
        if not self.validateHeaders():
            result = False

        return result

    def initHeadersToColumnMap(self):
        """compose a dictionary of {header name : header column} pairs containing only headers that were found"""

        for header in self.headersToLocMap:
            headerLoc = self.headersToLocMap[header]
            if headerLoc != '':
                # extract the header column name from the header location string (e.g., 'AB' from 'AB27')
                col = re.findall('^[A-Z]+', headerLoc)[0]
                self.headersToColumnMap.update({header: col})

    def findDataRowsRanges(self):
        """
        Returns a list of continuous usable data rows ranges

        Returns:
            :return (list): List of dictionaries {'From': None, 'To': None} for each continuous data rows range, 
                            or empty list [] if none has been found
        """

        dataRowsRanges = []                         # list of continuous continuous ranges of rows having source data
        rangeFrom = self.headersRowNumber + 1       # initial guess. empty rows after headers row are possible
        rangeTo = self.MAX_SEARCH_ROW

        done = False
        while not done:
            nextDataRowsRange = {'From': None, 'To': None}

            # find the start of the next range of data rows
            leadingNoneDataRowsCount = self.countLeadingNoneDataRows(rangeFrom, rangeTo)
            if leadingNoneDataRowsCount is None:
                # EOF reached and all rows between rangeFrom and rangeTo are none data rows
                nextDataRowsRange = None
                break
            else:
                # zero or more leading none data rows were found
                rangeFrom += leadingNoneDataRowsCount
                nextDataRowsRange['From'] = rangeFrom

            # find the end of the next range of data rows
            firstNoneDataRow = self.findFirstNoneDataRow(rangeFrom, rangeTo)
            if firstNoneDataRow is None:
                # EOF reached and all rows between nextRangeFrom and rangeTo are data rows 
                # (i.e., no none data rows were found in the given range)
                nextDataRowsRange['To'] = rangeTo
                done = True     # don't break before finalizing this iteration
            else:
                nextDataRowsRange['To'] = firstNoneDataRow - 1

            # finalize the current iteration
            dataRowsRanges.append(nextDataRowsRange)
            rangeFrom = firstNoneDataRow

        return dataRowsRanges

    def countLeadingNoneDataRows(self, fromRow, toRow):
        """counts the leading continuous empty rows in the given range"""
        
        noneDataRowCount = 0

        for row in range(fromRow, toRow):
            if self.isValidDataRow(row):
                # end of none data rows block found
                break

            # a none data row found
            noneDataRowCount += 1

            if noneDataRowCount == self.END_DATA_HINT:
                # min consecutive empty rows reached (i.e., a hint for end of properties source data)
                return None

        return noneDataRowCount

    def findFirstNoneDataRow(self, fromRow, toRow):
        """Returns the row number of the first row in the given range that has no data for property setting"""

        for row in range(fromRow, toRow):
            if not self.isValidDataRow(row):
                return row
 
        return None     # end of range reached with no empty data rows

    def isValidDataRow(self, row):
        """
        Validates a property data source row

        Notes:
            - a row having at least one valid content as data source for property setting is considered a valid row.
            - the column under the HEADER_VALUE header is ignored in the following process (i.e., it may or may not have values). 

        Args:
            :param row (int): Number of the row to be validated in the target spreadsheet

        Returns:
            :return (bool): True if valid, False otherwise.
        """

        result = False

        for header in self.headersToColumnMap:
            # iterate only over the property data sources columns headers (i.e., skip the value header)
            if header == self.context.HEADER_VALUE:
                continue

            dataCellLocation = self.headersToColumnMap[header] + str(row)
            cellContent = self.targetSpreadsheet.getContents(dataCellLocation)
            if cellContent == '':
                continue

            # prepare the validation function associated with the given header
            validationFunc, settingFunc = self.getPropertiesValidationAndSettingFunctions(header)

            # the property data cell has a value, if the value is valid consider the entire row as valid
            if validationFunc(cellContent):
                result = True
                break   # the row has relevant data. no need to iterate any further inside the inspected row.
            else:   
                # invalid value for a property data cell. keep trying other data columns of the inspected row
                pass

        return result

    def getPropertiesValidationAndSettingFunctions(self, header):
        """
        Returns header dependent Validation and Setting functions for properties

        Args:
            :param header (header_type_constant): The header of the column to which the provided property data source cell content belongs.
                                        The validation depends on the type of the header.
            :type header_type_constant: The property data source column header type constant defined by ActiveDocumentSheets 
                                         (e.g., HEADER_UNITS, HEADER_ALIAS)
        Returns:
            :return (tuple): References to Validation and Setting functions.
        """
        settingFuncName, validationFuncName = self.context.headerToFunctionsMap[header]
        settingFunc = getattr(self.targetSpreadsheet, settingFuncName)
        validationFunc = getattr(self, validationFuncName)

        return validationFunc, settingFunc

    def validateHeaders(self):
        """validates the headers as stored in the provided request parameters"""

        result = True
        oneFailedRuleReasons = []
        allFailedRulesReasons = []
        oneFailedRuleSeparator = ', '
        allFailedRulesSeparator = '\n\t'

        # Rule #1: all mandatory headers must exist
        for header in self.mandatoryHeaders:
            if self.headersToLocMap[header] == '':
                oneFailedRuleReasons.append(header)
                # look for all missing headers, don't stop on the first missing one.
                result = False

        if not result:
            # compose the reason string
            if len(oneFailedRuleReasons) == 1:
                reasonPrefix = 'Mandatory header is missing: '
            else:
                reasonPrefix = 'Mandatory headers are missing: '
            allFailedRulesReasons.append(reasonPrefix + oneFailedRuleSeparator.join(oneFailedRuleReasons))

        # Rule #2: headers row number has to be set
        if self.headersRowNumber is None:
            allFailedRulesReasons.append('Headers row number is missing')
            result = False

        # Rule #3: all headers must be on the same row
        for headerLoc in self.headersToLocMap.values():
            if headerLoc == '':
                continue
            # extract the header row number from the header location string (e.g., 27 from 'AB27')
            row = int(re.findall('[\d]+', headerLoc)[0])
            if row != self.headersRowNumber:
                allFailedRulesReasons.append('Not all the headers are on the same row')
                result = False

        # mark the hasValidHeaders flag appropriately and update the reason
        self.hasValidHeaders = result
        if not isEmpty(allFailedRulesReasons):
            self.invalidHeadersReason = allFailedRulesSeparator.join(allFailedRulesReasons)

        return result

    def validateUnits(self, units):
        try:
            FreeCAD.Units.parseQuantity(units)
            return True
        except IOError:
            return False

    def validateAlias(self, alias):
        # REVISIT: implement a true validation. 
        # temporarily we just count the number of words and accept only a single word as a valid alias.
        tokens = alias.split()
        return len(tokens) == 1

class SheetPropertiesActions:
    """
    Performs the requested action on the properties of selected cells in a 
    selected spreadsheet as indicated by the provided RequestParameters.

    Attributes:
        readAndSetProperties()  -- set the properties of the cells in the column having HEADER_VALUE header
                                   based on the data of the respective cells in the columns having the 
                                   data source headers (e.g., HEADER_UNITS, HEADER_ALIAS)
        clearProperties()       -- set the properties of the cells in the column having HEADER_VALUE header
    """

    def __init__(self, requestParams):
        self.requestParams = requestParams
        self.sheet = self.requestParams.targetSpreadsheet

    def readAndSetProperties(self, dataRowsRanges):
        """"""

        # expecting a valid dataRowsRanges
        if isEmpty(dataRowsRanges):
            print 'readAndSetProperties(): Internal Error: a valid dataRowsRanges is expected'
            return

        for dataRowsRange in dataRowsRanges:
            for row in range(dataRowsRange['From'], dataRowsRange['To'] + 1):
                # the cell location of the target cell for property setting needs to be updated only once per row
                valueCellLocation = self.requestParams.headersToColumnMap[self.requestParams.context.HEADER_VALUE] + str(row)
                for header in self.requestParams.headersToColumnMap:
                    # iterate only over the property data headers (i.e., skip the value header)
                    if header == self.requestParams.context.HEADER_VALUE:
                        continue

                    dataCellLocation = self.requestParams.headersToColumnMap[header] + str(row)
                    cellContent = self.sheet.getContents(dataCellLocation)
                    if cellContent == '':
                        continue

                    # prepare the validation function associated with the given header
                    validationFunc, settingFunc = self.requestParams.getPropertiesValidationAndSettingFunctions(header)

                    # the property data cell has a value, validate and if valid use it to set the respective property 
                    if validationFunc(cellContent):
                        settingFunc(valueCellLocation, cellContent)
                    else: 
                        print 'Ignoring invalid {0} \'{1}\' found at: {2}'.format(header, cellContent, dataCellLocation) 

        App.ActiveDocument.recompute()

    def clearProperties(self, dataRowsRanges):
        """"""

        # expecting a valid dataRowsRanges
        if isEmpty(dataRowsRanges):
            print 'readAndSetProperties(): Internal Error: a valid dataRowsRanges is expected'
            return

        rangeFrom = dataRowsRanges[0]['From']    # get 'From' value from the first tuple in the list
        rangeTo = dataRowsRanges[-1]['To']       # get 'To' value from the last tuple in the list

        for row in range(rangeFrom, rangeTo + 1):
            # the cell location of the target cell for property setting needs to be updated only once per row
            valueCellLocation = self.requestParams.headersToColumnMap[self.requestParams.context.HEADER_VALUE] + str(row)
            for header in self.requestParams.headersToColumnMap:
                # iterate only over the property data headers (i.e., skip the value header)
                if header == self.requestParams.context.HEADER_VALUE:
                    continue

                # prepare and execute the setting function associated with the given header
                validationFunc, settingFunc = self.requestParams.getPropertiesValidationAndSettingFunctions(header)
                settingFunc(valueCellLocation, '')

        App.ActiveDocument.recompute()

class TreeViewSelectionObserver:
    """Installable Observer for selections in the Tree View"""

    def __init__(self, subscriber):
        self.subscriber = subscriber

    def setSelection(self, doc):
        """called by the installed selection observer when a selection is made in the tree-view (aka, ComboView)"""

        # simple workaround to the unexplained behavior of getting two signals of setSelection when switching selection 
        # between objects that belong to two different parent documents.
        # it relies on the fact that getSelection() returns an empty list if the selected object does not belong to the active document
        sel = FreeCADGui.Selection.getSelection()
        if (not isEmpty(sel)):
            # true signal. delegate handling to subscriber normally.
            self.subscriber.onSetSelection(doc)
        else:
            # fake signal. signal suppressed.
            pass

class MainFormUI(QtGui.QMainWindow):
    """
    UI definitions of the central widget for the main form

    Attributes:
        selectSheetComboBox         -- QtGui.QComboBox to be populated and connected to signal handlers by the consumer
        rangeFromSpinBox            -- QtGui.QSpinBox to be connected to signal handlers by the consumer
        rangeToSpinBox              -- QtGui.QSpinBox to be connected to signal handlers by the consumer
        setPropertiesPushButton     -- QtGui.QPushButton to be connected to signal handlers by the consumer
        clearPropertiesPushButton   -- QtGui.QPushButton to be connected to signal handlers by the consumer
        statusTextContent           -- QtGui.QTextEdit to be populated by the consumer
        statusRefreshPushButton     -- QtGui.QPushButton to be connected to signal handlers by the consumer
        dismissPushButton           -- QtGui.QPushButton to be connected to signal handlers by the consumer
    """

    def __init__(self):
        super(MainFormUI, self).__init__()
        self.initUI()

    def initUI(self):
        # define window
        self.setGeometry(250, 250, 400, 515)    # xLoc,yLoc,width,height
        self.setWindowTitle("Sheet Properties Actions")
        self.setWindowFlags(QtCore.Qt.MSWindowsFixedSizeDialogHint | QtCore.Qt.WindowStaysOnTopHint)
        font = QtGui.QFont()
        font.setStyleStrategy(QtGui.QFont.PreferAntialias)
        font.setPixelSize(12)
        font.setFamily('Verdana')
        self.setFont(font)

        # target spread sheet selection group
        targetSheetGroupBox = QtGui.QGroupBox('Target Spreadsheet:', self)
        targetSheetGroupBox.setGeometry(10, 10, 380, 50)    # xLoc,yLoc,width,height
        # pop-up menu for selecting the target spreadsheet (will be populated by the consuming object)
        self.selectSheetComboBox = QtGui.QComboBox(self)
        self.selectSheetComboBox.setMinimumSize(300,23)        # width,height
        self.selectSheetComboBox.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)
        targetSheetGroupBoxLayout = QtGui.QVBoxLayout()
        targetSheetGroupBoxLayout.addWidget(self.selectSheetComboBox)
        targetSheetGroupBox.setLayout(targetSheetGroupBoxLayout)

        # target rows range group
        targetRowsRangeGroupBox = QtGui.QGroupBox('Target Rows Range:', self)
        targetRowsRangeGroupBox.setGeometry(10, 70, 380, 130)    # xLoc,yLoc,width,height
        # mode (custom/auto) radio buttons
        self.AutoTargetRowsRangeRadioButton = QtGui.QRadioButton('Auto')
        self.CustomTargetRowsRangeRadioButton = QtGui.QRadioButton('Custom')
        self.targetRowsRangeRadioButtonsGroup = QtGui.QButtonGroup()
        self.targetRowsRangeRadioButtonsGroup.addButton(self.AutoTargetRowsRangeRadioButton)
        self.targetRowsRangeRadioButtonsGroup.addButton(self.CustomTargetRowsRangeRadioButton)
        targetRowsRangeRadioButtonsLayout = QtGui.QHBoxLayout()
        targetRowsRangeRadioButtonsLayout.addWidget(self.AutoTargetRowsRangeRadioButton)
        targetRowsRangeRadioButtonsLayout.addWidget(self.CustomTargetRowsRangeRadioButton)
        # custom 'from' row
        rangeFromRowLabel = QtGui.QLabel("From:", self)
        self.rangeFromRowSpinBox = QtGui.QSpinBox()
        rangeFromRowLayout = QtGui.QHBoxLayout()
        rangeFromRowLayout.addStretch(1)    # align to the right
        rangeFromRowLayout.addWidget(rangeFromRowLabel)
        rangeFromRowLayout.addWidget(self.rangeFromRowSpinBox)
        # custom 'to' row
        rangeToRowLabel = QtGui.QLabel("To:", self)
        self.rangeToRowSpinBox = QtGui.QSpinBox()
        rangeToRowLayout = QtGui.QHBoxLayout()
        rangeToRowLayout.addWidget(rangeToRowLabel)
        rangeToRowLayout.addWidget(self.rangeToRowSpinBox)
        # custom 'from' row and 'to' row combined layout
        customTargetRowsRangeLayout = QtGui.QHBoxLayout()
        customTargetRowsRangeLayout.addLayout(rangeFromRowLayout)
        customTargetRowsRangeLayout.addLayout(rangeToRowLayout)
        # mode radio buttons and custom range layout
        modeAndCustomRangeLayout = QtGui.QHBoxLayout()
        modeAndCustomRangeLayout.addLayout(targetRowsRangeRadioButtonsLayout)
        modeAndCustomRangeLayout.addLayout(customTargetRowsRangeLayout)
        # auto discovered rows range display area
        self.AutoTargetRowsRangeTextContent = QtGui.QTextEdit()
        self.AutoTargetRowsRangeTextContent.setReadOnly(True)
        self.AutoTargetRowsRangeTextContent.setTabStopWidth(20)      # Tab stop width in pixels (default: 80 pixels)
        # combined layout
        targetRowsRangeLayout = QtGui.QVBoxLayout()
        targetRowsRangeLayout.addLayout(modeAndCustomRangeLayout)
        targetRowsRangeLayout.addWidget(self.AutoTargetRowsRangeTextContent)
        targetRowsRangeGroupBox.setLayout(targetRowsRangeLayout)

        # actions selection group
        actionsGroupBox = QtGui.QGroupBox('Actions:', self)
        actionsGroupBox.setGeometry(10, 210, 380, 50)   # xLoc,yLoc,width,height
        self.setPropertiesPushButton = QtGui.QPushButton('&Set', self)
        self.setPropertiesPushButton.setMinimumSize(81,23)        # width,height
        self.setPropertiesPushButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.clearPropertiesPushButton = QtGui.QPushButton('&Clear', self)
        self.clearPropertiesPushButton.setMinimumSize(81,23)      # width,height
        self.clearPropertiesPushButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        actionsGroupBoxLayout = QtGui.QHBoxLayout()
        actionsGroupBoxLayout.addWidget(self.setPropertiesPushButton)
        actionsGroupBoxLayout.addWidget(self.clearPropertiesPushButton)
        actionsGroupBox.setLayout(actionsGroupBoxLayout)

        # status group
        statusGroupBox = QtGui.QGroupBox('Status:', self)
        statusGroupBox.setGeometry(10, 270, 380, 200)   # xLoc,yLoc,width,height
        self.statusTextContent = QtGui.QTextEdit()
        self.statusTextContent.setReadOnly(True)
        self.statusTextContent.setTabStopWidth(40)      # Tab stop width in pixels (default: 80 pixels)
        self.statusRefreshPushButton = QtGui.QPushButton('&Refresh', self)
        self.statusRefreshPushButton.setMinimumSize(81,23)        # width,height
        self.statusRefreshPushButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        statusGroupBoxLayout = QtGui.QVBoxLayout()
        statusGroupBoxLayout.addWidget(self.statusTextContent)
        statusGroupBoxLayout.addWidget(self.statusRefreshPushButton)
        statusGroupBox.setLayout(statusGroupBoxLayout)

        # 'dismissPushButton' button
        self.dismissPushButton = QtGui.QPushButton('&Dismiss', self)
        self.dismissPushButton.setMinimumSize(81,23)        # width,height
        self.dismissPushButton.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.dismissPushButton.move(160, 480)
        #dismissPushButtonLayout = QtGui.QHBoxLayout()
        #dismissPushButtonLayout.addWidget(self.dismissPushButton)

        # arrange the layout of the main form UI with all its elements
        #mainFormUILayout = QtGui.QHBoxLayout(self)
        #mainFormUILayout.addWidget(targetSheetGroupBox)
        #mainFormUILayout.addWidget(targetRowsRangeGroupBox)
        #mainFormUILayout.addWidget(actionsGroupBox)
        #mainFormUILayout.addWidget(statusGroupBox)
        #mainFormUILayout.addLayout(dismissPushButtonLayout)
        #self.setLayout(mainFormUILayout)

class SheetPropertiesActionsForm(MainFormUI):
    """
    A form interactively collecting the request parameters for actions on the 
    properties of selected cells in a selected spreadsheet.
    
    This class provides the functional logic for a concrete UI (the base class for this class) that is defined elsewhere.

    When confirmed, the properties are set according to the current request 
    parameters.
    """

    # status message types
    STATUS_INFO = 0
    STATUS_ERROR = 1

    def __init__(self, context):
        self.context = context
        self.targetSpreadsheet = None   # selected target spreadsheet
        self.requestParams = None       # request params associated with the selected target spreadsheet

        super(SheetPropertiesActionsForm, self).__init__()
        self.initForm()

    def initForm(self):

        # populate the pop-up menu for selecting the target spreadsheet from all the spreadsheets included in the active document.
        # note that if signal handling methods for this ComboBx were installed before this point, then if the signals are not blocked, 
        # adding items to a ComboBox also triggers the currentIndexChanged signals, and this may be undesired before completing initialization.
        for sheet in self.context.getSheets():
            self.selectSheetComboBox.addItem(sheet.Label)

        # connect signal handling methods
        self.selectSheetComboBox.currentIndexChanged.connect(self.onSelectSheetComboBoxCurrentIndexChanged)
        self.selectSheetComboBox.activated[str].connect(self.onSelectSheetComboBoxActivated)
        self.AutoTargetRowsRangeRadioButton.clicked.connect(self.onTargetRowsRangeModeChanged)
        self.CustomTargetRowsRangeRadioButton.clicked.connect(self.onTargetRowsRangeModeChanged)
        self.rangeFromRowSpinBox.valueChanged[str].connect(self.onRangeFromRowSpinBoxValueChanged)
        self.rangeToRowSpinBox.valueChanged[str].connect(self.onRangeToRowSpinBoxValueChanged)
        self.setPropertiesPushButton.clicked.connect(self.onSetProperties)
        self.clearPropertiesPushButton.clicked.connect(self.onClearProperties)
        self.statusRefreshPushButton.clicked.connect(self.onRefreshStatus)
        self.dismissPushButton.clicked.connect(self.onDismiss)

        # Install a selection observer
        self.treeViewSelectionObserver = TreeViewSelectionObserver(self)
        FreeCADGui.Selection.addObserver(self.treeViewSelectionObserver)

        # sync selections in the right direction with a particular order (tree view gets priority)
        if self.context.getSelectedSheet() is not None:
            self.syncComboBoxFromTreeViewSelection()
            # the next condition deals with unique initial state in which the first sheet is selected in the tree view,
            # and the combo box is already showing the first sheet as the selected one by default (even without sync
            # of combo box from the tree view selection). in this case, the self.selectSheetComboBox.currentIndexChanged 
            # signal is not fired and self.handleTargetSpreadsheetChanged() is not called from that signal handler.
            if self.selectSheetComboBox.currentIndex() == 0:
                self.handleTargetSpreadsheetChanged()
        else:
            self.syncTreeViewFromComboBoxSelection(self.selectSheetComboBox.currentText())
            self.handleTargetSpreadsheetChanged()

        # make the window visible
        self.show()

    def syncComboBoxFromTreeViewSelection(self):
        """Sync the selection in the pop-up menu with the selection in the Tree View"""

        # when the first selected item in the active document tree view is a spreadsheet, set it as the default 
        # in the combo box (i.e., target spreadsheet selection pop-up menu)
        selectedSheet = self.context.getSelectedSheet()
        comboBoxItems = [self.selectSheetComboBox.itemText(i) for i in range(self.selectSheetComboBox.count())]
        if selectedSheet is not None and selectedSheet.Label in comboBoxItems:
            # self.targetSpreadsheet has to be set before setting a new index for selectSheetComboBox combo box, as the last 
            # fires a self.selectSheetComboBox.currentIndexChanged signal and its handler rely on current self.targetSpreadsheet.
            # alternatively, we could block the currentIndexChanged signals until we are done here.
            self.targetSpreadsheet = selectedSheet
            self.selectSheetComboBox.setCurrentIndex(comboBoxItems.index(selectedSheet.Label))

    def syncTreeViewFromComboBoxSelection(self, selectedText):
        """Sync the selection in the Tree View with the selection in the pop-up menu"""

        if selectedText in self.context.sheetLabelToSheetMap:
            self.targetSpreadsheet = self.context.sheetLabelToSheetMap[selectedText]
        else:
            print 'syncTreeViewFromComboBoxSelection(): Internal Error: \'{0}\' is unknown'.format(selectedText)
            self.close()

        # update the selection in the tree view to reflect the selection in the ComboBox
        FreeCADGui.Selection.clearSelection()
        FreeCADGui.Selection.addSelection(self.targetSpreadsheet)

    def appendStatus(self, statusMessage, statusMessageType=STATUS_INFO):
        # preserve current text color
        previousTextColor = self.statusTextContent.textColor() 

        if statusMessageType == self.STATUS_ERROR:
            self.statusTextContent.setTextColor(QtCore.Qt.red)

        self.statusTextContent.append(str(statusMessage))
        self.statusTextContent.update()

        # restore previous text color
        self.statusTextContent.setTextColor(previousTextColor)

        # show the same text also on the 'Report View' panel of FreeCAD
        print statusMessage

    def clearStatus(self):
        self.statusTextContent.clear()
        self.update()

    def enableCustomDataRowsRangeSetting(self, enable):
        self.rangeFromRowSpinBox.setEnabled(enable)
        self.rangeToRowSpinBox.setEnabled(enable)

    def getCustomDataRowsRange(self):
        customDataRowsRange = {'From': None, 'To': None}
        customDataRowsRange['From'] = self.rangeFromRowSpinBox.value()
        customDataRowsRange['To'] = self.rangeToRowSpinBox.value()

        return [customDataRowsRange]

    def displayStatusMessage(self):
        # clear the current content of the status display then print the new content
        self.clearStatus()
        if self.requestParams.hasValidHeaders:
            statusMessage = 'Valid headers found for sheet \'{0}\' at:'.format(self.targetSpreadsheet.Label)
            self.appendStatus(statusMessage)
            statusMessage = '\t' + str(self.requestParams.headersToLocMap) + '\n'
            self.appendStatus(statusMessage)
        else:
            statusMessage = 'Invalid headers for sheet \'{0}\':'.format(self.targetSpreadsheet.Label)
            self.appendStatus(statusMessage, self.STATUS_ERROR)
            statusMessage = '\t' + self.requestParams.invalidHeadersReason
            self.appendStatus(statusMessage, self.STATUS_ERROR)
            statusMessage = '\nSheet \'{0}\' cannot be used'.format(self.targetSpreadsheet.Label)
            self.appendStatus(statusMessage, self.STATUS_ERROR)
            statusMessage = 'Fix the problem or select a valid sheet'
            self.appendStatus(statusMessage, self.STATUS_ERROR)

        if self.requestParams.hasValidPropertiesData:
            statusMessage = 'Valid data rows found for sheet \'{0}\''.format(self.targetSpreadsheet.Label)
            self.appendStatus(statusMessage)
        else:
            statusMessage = self.requestParams.invalidPropertiesDataReason
            self.appendStatus(statusMessage, self.STATUS_ERROR)

    def displayDataRowsRanges(self):
        if self.requestParams.hasValidPropertiesData:
            # a dictionary does not track the insertion order, and iterating over it produces the values in an arbitrary order.
            # sort the ranges that were found and replace the double-quotes with single-quotes to make it easier to the eyes.
            sortedRanges = json.dumps(self.requestParams.dataRowsRanges, sort_keys = True)
            sortedRanges = re.sub('"', '\'', sortedRanges)
            self.AutoTargetRowsRangeTextContent.setPlainText(sortedRanges)
        else:
            self.AutoTargetRowsRangeTextContent.clear()

    def setValueAndMinimumForCustomRowsRange(self):
        # prepare initial and min/max values for the custom range spin boxes
        # assume no valid headers were found, set initial and minimum values for the custom range spin boxes to be 1
        rangeFromRowSpinBoxMinimum = 1
        rangeToRowSpinBoxMinimum = 1
        rangeFromRowSpinBoxMaximum = self.requestParams.MAX_SEARCH_ROW
        rangeToRowSpinBoxMaximum = self.requestParams.MAX_SEARCH_ROW
        rangeFromRowSpinBoxValue = 1
        rangeToRowSpinBoxValue = 1
        if self.requestParams.hasValidHeaders:
            # both rangeFromRowSpinBox and rangeToRowSpinBox must have values higher than the headers row number  
            rangeFromRowSpinBoxMinimum = self.requestParams.headersRowNumber + 1
            rangeToRowSpinBoxMinimum = self.requestParams.headersRowNumber + 1
            if self.requestParams.hasValidPropertiesData:
                # bound the data rows ranges that were found (by taking th extreme values)
                rangeFromRowSpinBoxValue = self.requestParams.dataRowsRanges[0]['From']
                rangeToRowSpinBoxValue = self.requestParams.dataRowsRanges[-1]['To']

        # set min/max for the custom range spin boxes
        self.rangeFromRowSpinBox.setMinimum(rangeFromRowSpinBoxMinimum)  
        self.rangeToRowSpinBox.setMinimum(rangeToRowSpinBoxMinimum)  
        self.rangeFromRowSpinBox.setMaximum(rangeFromRowSpinBoxMaximum)  
        self.rangeToRowSpinBox.setMaximum(rangeToRowSpinBoxMaximum) 

        # set initial values based on the ranges found automatically
        self.rangeFromRowSpinBox.setValue(rangeFromRowSpinBoxValue)
        self.rangeToRowSpinBox.setValue(rangeToRowSpinBoxValue)

    def setDefaultRowsRangeSettingMode(self):
        if self.requestParams.hasValidHeaders:
            self.AutoTargetRowsRangeRadioButton.setEnabled(True)
            self.CustomTargetRowsRangeRadioButton.setEnabled(True)
            if self.requestParams.hasValidPropertiesData:
                self.AutoTargetRowsRangeRadioButton.setChecked(True)
                self.enableCustomDataRowsRangeSetting(False)
            else:
                self.CustomTargetRowsRangeRadioButton.setChecked(True)
                self.enableCustomDataRowsRangeSetting(True)
        else:
            # the sheet is unusable. nothing is allowed.
            self.enableCustomDataRowsRangeSetting(False)
            self.AutoTargetRowsRangeRadioButton.setEnabled(False)
            self.CustomTargetRowsRangeRadioButton.setEnabled(False)


    def setActionsAvailability(self):

        # enable the 'set' properties action based on the validity of the target sheet
        if self.requestParams.hasValidHeaders and self.requestParams.hasValidPropertiesData:
            self.setPropertiesPushButton.setEnabled(True)
        else:
            self.setPropertiesPushButton.setEnabled(False)

        # enable the 'clear' properties action based on the validity of the target sheet
        if self.requestParams.hasValidHeaders:
            self.clearPropertiesPushButton.setEnabled(True)
        else:
            self.clearPropertiesPushButton.setEnabled(False)

    def handleTargetSpreadsheetChanged(self):
        """
        Called after a new target spreadsheet has been selected using 
        either the pop-up menu or the tree view. 

        This is the central location for setting the SheetPropertiesActionsForm based on the selected concrete target sheet.
        This includes for instance, updating the displayed status messages and displayed valid data ranges, recalculate the 
        default values for the custom target data rows range, and enable and disable widgets.
        """

        # expecting the targetSpreadsheet attribute of SheetPropertiesActionsForm to be current.
        if self.targetSpreadsheet is None:
            print 'handleTargetSpreadsheetChanged(): Internal Error: a valid target spreadsheet is expected'
            return

        # for convenience, keep a local copy of the reference to the current requestParams in SheetPropertiesActionsForm
        self.requestParams = self.context.sheetToRequestParamsMap[self.targetSpreadsheet]

        # perform operations based on the validity of the headers and data rows of the selected target sheet
        self.displayStatusMessage()
        self.displayDataRowsRanges()
        self.setValueAndMinimumForCustomRowsRange()
        self.setDefaultRowsRangeSettingMode()
        self.setActionsAvailability()
           
    def onSelectSheetComboBoxCurrentIndexChanged(self, selectedIndex):
        # sync and handle selected target sheet
        self.syncTreeViewFromComboBoxSelection(self.selectSheetComboBox.itemText(selectedIndex))
        self.handleTargetSpreadsheetChanged()

    def onSelectSheetComboBoxActivated(self, selectedText):
        # ignore this signal. the onSelectSheetComboBoxCurrentIndexChanged() is taking care of selection changes.
        pass

    def onTargetRowsRangeModeChanged(self):
        # enable the custom range settings spin boxes only in custom mode
        if self.targetRowsRangeRadioButtonsGroup.checkedButton().text() == 'Custom':
            self.enableCustomDataRowsRangeSetting(True)
            # we allow unconditionally using the 'Clear' action in this state
            self.clearPropertiesPushButton.setEnabled(True)
        else:
            self.enableCustomDataRowsRangeSetting(False)
            if self.requestParams.hasValidPropertiesData:
                self.clearPropertiesPushButton.setEnabled(True)
            else:
                # we allow selecting 'Auto' in this state, but the 'Clear' action has to be disabled
                self.clearPropertiesPushButton.setEnabled(False)

    def onRangeFromRowSpinBoxValueChanged(self):
        rangeTo = self.rangeToRowSpinBox.value()
        if self.rangeFromRowSpinBox.value() > rangeTo:
            self.rangeFromRowSpinBox.setValue(rangeTo)

    def onRangeToRowSpinBoxValueChanged(self):
        rangeFrom = self.rangeFromRowSpinBox.value()
        if self.rangeToRowSpinBox.value() < rangeFrom:
            self.rangeToRowSpinBox.setValue(rangeFrom)

    def onDismiss(self):
        self.close()

    def onSetProperties(self):

        # expecting valid headers for the selected target sheet
        if not self.requestParams.hasValidPropertiesData:
            print 'onSetProperties(): Internal Error. The \'Set\' action button was supposed to be disabled'
            return

        # perform the actual cells properties setting based on the relevant request parameters
        sheetPropertyActions = SheetPropertiesActions(self.requestParams)
        if self.targetRowsRangeRadioButtonsGroup.checkedButton().text() == 'Auto':
            sheetPropertyActions.readAndSetProperties(self.requestParams.dataRowsRanges)
        else:
            sheetPropertyActions.readAndSetProperties(self.getCustomDataRowsRange())

    def onClearProperties(self):
        
        # expecting valid headers for the selected target sheet
        if not self.requestParams.hasValidHeaders:
            print 'onClearProperties(): Internal Error. The \'Clear\' action button was supposed to be disabled'
            return

        # clear the properties of the target cells based on the relevant request parameters
        sheetPropertyActions = SheetPropertiesActions(self.requestParams)
        if self.targetRowsRangeRadioButtonsGroup.checkedButton().text() == 'Auto':
            sheetPropertyActions.clearProperties(self.requestParams.dataRowsRanges)
        else:
            sheetPropertyActions.clearProperties(self.getCustomDataRowsRange())

    def onRefreshStatus(self):
        # REVISIT: Improve implementation to show the updated status of the selected sheet
        print 'onRefreshStatus() entered'
        self.clearStatus()

    def onSetSelection(self, doc):
        """Called by the selection observer when a new selection is done in the tree view"""

        if doc == self.context.activeDocument.Name:
            # Sync the selection in the tree view with the pop-up menu
            self.syncComboBoxFromTreeViewSelection()
        else:
            # we could set the parent document of the new selection as the active document as follows:
            #App.setActiveDocument(doc)
            # but, at least for now, we will suppress the signal and leave it to the user to decide
            statusMessage =  'The selected sheet does not belong to the active document \'{0}\''.format(self.context.activeDocument.Name)
            self.appendStatus(statusMessage, self.STATUS_ERROR)
            statusMessage =  'The parent document \'{0}\' has to be activated first'.format(doc)
            self.appendStatus(statusMessage, self.STATUS_ERROR)

    def closeEvent(self, event):
        """Called when the user closes the window or when the code calls QWidget.close() to close a widget programmatically"""

        print 'Form Closed'

        # -----------------------------------------------------------------------
        # Cleanup
        # -----------------------------------------------------------------------

        # Uninstall the selection observer
        FreeCADGui.Selection.removeObserver(self.treeViewSelectionObserver)

        return self

# -----------------------------------------------------------------------
# Utilities
# -----------------------------------------------------------------------

def isEmpty(anyStruct):
    """Checks if a built-in structure is empty"""
    return False if anyStruct else True

def colNumberToColName(colNumber):
    """Converts a 1-based column number to Excel style column name (i.e., 1 to 'A' up to 702 to 'ZZ')"""
    alphabetList = string.ascii_uppercase
    alphabetListLen = len(alphabetList)
    d, m = divmod(colNumber-1, alphabetListLen)
    return alphabetList[d-1] + alphabetList[m] if (colNumber>alphabetListLen) else alphabetList[colNumber-1]

class PreconditionError(Exception):
    """Custom Exception raised for precondition violation.

    Attributes:
        reason -- explanation of the error
    """
    def __init__(self, reason):
        self.reason = reason
    def __str__(self):
        return repr(self.reason)
# -----------------------------------------------------------------------
# Entry point
# -----------------------------------------------------------------------

# execute main() only if this code is run as a script and not if imported as a module.
if __name__ == "__main__":
    form = main()   # maintain a reference to the main window to avoid a premature garbage collection
